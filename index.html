<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Analysis with Gemini AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fafafa;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #262730;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .sidebar {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .sidebar h3 {
            color: #262730;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .api-key-section {
            margin-bottom: 25px;
        }

        .api-key-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .api-key-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: white;
        }

        .api-key-selector:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .api-key-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .api-key-label-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .save-api-key-button, .delete-api-key-button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .save-api-key-button {
            background-color: #28a745;
            color: white;
        }

        .save-api-key-button:hover {
            background-color: #218838;
        }

        .save-api-key-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .delete-api-key-button {
            background-color: #dc3545;
            color: white;
        }

        .delete-api-key-button:hover {
            background-color: #c82333;
        }

        .delete-api-key-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .auto-rotation-section {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .auto-rotation-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #4CAF50;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .current-api-indicator {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-top: 5px;
            padding: 5px 8px;
            background-color: #e3f2fd;
            border-radius: 4px;
            border-left: 3px solid #2196F3;
        }

        .rotation-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .import-export-section {
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .import-export-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .export-button, .import-button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .export-button {
            background-color: #17a2b8;
            color: white;
        }

        .export-button:hover:not(:disabled) {
            background-color: #138496;
        }

        .export-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .import-button {
            background-color: #28a745;
            color: white;
        }

        .import-button:hover:not(:disabled) {
            background-color: #218838;
        }

        .import-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .import-export-title {
            font-weight: 500;
            color: #333;
            margin-bottom: 5px;
        }

        .import-export-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .prompt-management-section {
            margin-bottom: 25px;
        }

        .prompt-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .prompt-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            background-color: white;
        }

        .prompt-item:last-child {
            border-bottom: none;
        }

        .prompt-item.disabled {
            background-color: #f8f9fa;
            opacity: 0.7;
        }

        .prompt-toggle {
            margin-right: 10px;
        }

        .prompt-toggle input[type="checkbox"] {
            transform: scale(1.1);
            accent-color: #4CAF50;
        }

        .prompt-details {
            flex: 1;
            min-width: 0;
        }

        .prompt-name {
            font-weight: 500;
            color: #333;
            font-size: 13px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .prompt-meta {
            font-size: 11px;
            color: #666;
            display: flex;
            gap: 8px;
        }

        .prompt-badge {
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: bold;
        }

        .prompt-badge.custom {
            background-color: #fff3e0;
            color: #f57c00;
        }

        .prompt-controls {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .prompt-control-btn {
            padding: 4px 6px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .edit-btn {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .edit-btn:hover {
            background-color: #bbdefb;
        }

        .delete-btn {
            background-color: #ffebee;
            color: #d32f2f;
        }

        .delete-btn:hover {
            background-color: #ffcdd2;
        }

        .delete-btn:disabled {
            background-color: #f5f5f5;
            color: #cccccc;
            cursor: not-allowed;
        }

        .reset-btn {
            background-color: #f3e5f5;
            color: #9c27b0;
        }

        .reset-btn:hover {
            background-color: #e1bee7;
        }

        .duplicate-btn {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        .duplicate-btn:hover {
            background-color: #c8e6c9;
        }

        .prompt-management-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .add-prompt-btn {
            background-color: #4CAF50;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            flex: 1;
        }

        .add-prompt-btn:hover {
            background-color: #45a049;
        }

        .reset-all-btn {
            background-color: #ff9800;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            flex: 1;
        }

        .reset-all-btn:hover {
            background-color: #f57c00;
        }

        .prompt-import-export {
            padding: 12px;
            background-color: #f0f7ff;
            border-radius: 6px;
            border: 1px solid #d0e7ff;
            margin-top: 15px;
        }

        .prompt-import-export-title {
            font-weight: 500;
            color: #333;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .prompt-import-export-description {
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
        }

        .prompt-import-export-controls {
            display: flex;
            gap: 8px;
        }

        .export-prompts-btn, .import-prompts-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            flex: 1;
            transition: background-color 0.3s;
        }

        .export-prompts-btn {
            background-color: #2196F3;
            color: white;
        }

        .export-prompts-btn:hover:not(:disabled) {
            background-color: #1976D2;
        }

        .export-prompts-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .import-prompts-btn {
            background-color: #4CAF50;
            color: white;
        }

        .import-prompts-btn:hover:not(:disabled) {
            background-color: #388E3C;
        }

        /* Modal Editor Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px 25px 15px 25px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background-color: #f5f5f5;
            color: #333;
        }

        .modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .form-textarea {
            width: 100%;
            height: 350px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.2s;
            box-sizing: border-box;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .form-help {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .character-counter {
            font-size: 12px;
            color: #999;
            text-align: right;
            margin-top: 5px;
        }

        .modal-footer {
            padding: 15px 25px 20px 25px;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .modal-button-primary {
            background-color: #4CAF50;
            color: white;
        }

        .modal-button-primary:hover {
            background-color: #45a049;
        }

        .modal-button-primary:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .modal-button-secondary {
            background-color: #f5f5f5;
            color: #333;
        }

        .modal-button-secondary:hover {
            background-color: #e9ecef;
        }

        .error-message {
            color: #d32f2f;
            font-size: 12px;
            margin-top: 5px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        @media (max-width: 768px) {
            .modal-content {
                max-width: 95%;
                margin: 10px;
            }
            
            .modal-header, .modal-body, .modal-footer {
                padding-left: 15px;
                padding-right: 15px;
            }
        }

        .model-selection-section {
            margin-bottom: 25px;
        }

        .model-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: white;
        }

        .model-selector:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .model-info {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-size: 12px;
        }

        .model-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .model-capabilities {
            color: #666;
            margin-bottom: 3px;
        }

        .model-description {
            color: #555;
            font-style: italic;
        }

        .model-badge {
            display: inline-block;
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-right: 5px;
            margin-bottom: 3px;
        }

        .model-badge.premium {
            background-color: #fff3e0;
            color: #f57c00;
        }

        .model-badge.fast {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        .model-badge.lite {
            background-color: #f3e5f5;
            color: #9c27b0;
        }

        .status {
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .processing-order, .tips {
            margin-bottom: 20px;
        }

        .processing-order ul, .tips ul {
            list-style: none;
            padding-left: 0;
        }

        .processing-order li, .tips li {
            padding: 5px 0;
            color: #666;
            font-size: 14px;
        }

        .content-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .input-section, .results-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .input-section h2, .results-section h2 {
            color: #262730;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .transcript-input {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            font-family: monospace;
            line-height: 1.5;
        }

        .transcript-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .process-button {
            width: 100%;
            padding: 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        .process-button:hover:not(:disabled) {
            background-color: #45a049;
        }

        .process-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #f0f0f0;
            border-radius: 3px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .status-text {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }

        .tabs {
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
        }

        .tab {
            display: inline-block;
            padding: 12px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #4CAF50;
            border-bottom-color: #4CAF50;
            font-weight: bold;
        }

        .tab:hover {
            color: #4CAF50;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .response-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 200px;
        }

        .response-text {
            white-space: pre-wrap;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .copy-button {
            background-color: #008CBA;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .copy-button:hover {
            background-color: #007B9A;
        }

        .download-section {
            border-top: 2px solid #ddd;
            padding-top: 20px;
            margin-top: 20px;
        }

        .download-button {
            background-color: #6c757d;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .download-button:hover {
            background-color: #5a6268;
        }

        .individual-prompts {
            margin-top: 30px;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .individual-prompts h3 {
            margin-bottom: 20px;
            color: #262730;
        }

        .prompt-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .prompt-item:last-child {
            border-bottom: none;
        }

        .prompt-name {
            font-weight: 500;
            color: #333;
        }

        .individual-process-button {
            background-color: #17a2b8;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .individual-process-button:hover:not(:disabled) {
            background-color: #138496;
        }

        .individual-process-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }

        .no-results {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px 20px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 300px 1fr;
            }
        }

        @media (max-width: 968px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .content-area {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: relative;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 Daily Analysis with Gemini AI</h1>
            <p>Process your daily transcripts through multiple AI prompts for comprehensive analysis</p>
        </div>

        <div class="main-layout">
            <div class="sidebar">
                <div class="model-selection-section">
                    <h3>🤖 Model Selection</h3>
                    <select id="modelSelector" class="model-selector">
                        <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                        <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash-Lite</option>
                    </select>
                    <div id="modelInfo" class="model-info">
                        <!-- Model information will be populated here -->
                    </div>
                </div>

                <div class="api-key-section">
                    <h3>⚙️ API Key Management</h3>
                    
                    <select id="apiKeySelector" class="api-key-selector">
                        <option value="">Select saved API key...</option>
                    </select>
                    
                    <input 
                        type="password" 
                        id="apiKey" 
                        class="api-key-input" 
                        placeholder="Enter new Google AI Studio API key"
                        autocomplete="off"
                    >
                    
                    <div class="api-key-controls">
                        <input 
                            type="text" 
                            id="apiKeyLabel" 
                            class="api-key-label-input" 
                            placeholder="Label (e.g., 'Personal', 'Work')"
                            maxlength="20"
                        >
                        <button id="saveApiKeyButton" class="save-api-key-button" disabled>
                            💾 Save
                        </button>
                        <button id="deleteApiKeyButton" class="delete-api-key-button" disabled>
                            🗑️ Delete
                        </button>
                    </div>
                    
                    <div id="apiStatus" class="status" style="display: none;"></div>
                    
                    <div class="auto-rotation-section">
                        <div class="auto-rotation-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoRotateToggle">
                                <span class="toggle-slider"></span>
                            </label>
                            <label for="autoRotateToggle" style="cursor: pointer; font-weight: 500;">
                                🔄 Auto-rotate API keys
                            </label>
                        </div>
                        <div class="rotation-status">
                            Distribute requests across multiple API keys to manage usage limits
                        </div>
                        <div id="currentApiIndicator" class="current-api-indicator" style="display: none;">
                            Current: <span id="currentApiLabel"></span>
                        </div>
                    </div>

                    <div class="import-export-section">
                        <div class="import-export-title">💾 Backup & Restore</div>
                        <div class="import-export-description">
                            Export your API keys for backup or import from a JSON file
                        </div>
                        <div class="import-export-controls">
                            <button id="exportKeysButton" class="export-button">
                                📤 Export Keys
                            </button>
                            <button id="importKeysButton" class="import-button">
                                📥 Import Keys
                            </button>
                            <input type="file" id="importFileInput" class="file-input" accept=".json" />
                        </div>
                    </div>
                </div>

                <div class="prompt-management-section">
                    <h3>🎛️ Prompt Management</h3>
                    <div id="promptList" class="prompt-list">
                        <!-- Prompt items will be populated here -->
                    </div>
                    <div class="prompt-management-controls">
                        <button id="addPromptButton" class="add-prompt-btn">
                            ➕ Add Prompt
                        </button>
                        <button id="resetAllPromptsButton" class="reset-all-btn">
                            🔄 Reset All
                        </button>
                    </div>
                    <div class="prompt-import-export">
                        <div class="prompt-import-export-title">📦 Prompt Library</div>
                        <div class="prompt-import-export-description">
                            Export your prompts to share or backup, or import prompt collections
                        </div>
                        <div class="prompt-import-export-controls">
                            <button id="exportPromptsButton" class="export-prompts-btn">
                                📤 Export Prompts
                            </button>
                            <button id="importPromptsButton" class="import-prompts-btn">
                                📥 Import Prompts
                            </button>
                            <input type="file" id="importPromptsFileInput" class="file-input" accept=".json" />
                        </div>
                    </div>
                </div>

                <div class="processing-order">
                    <h3>📝 Processing Order:</h3>
                    <ul id="processingOrder">
                        <!-- Will be dynamically populated -->
                    </ul>
                </div>

                <div class="tips">
                    <h3>💡 Tips:</h3>
                    <ul>
                        <li>• Paste your transcript in the text area</li>
                        <li>• Click 'Process All' to run all prompts</li>
                        <li>• Or process prompts individually</li>
                        <li>• Copy responses with the copy button</li>
                    </ul>
                </div>
            </div>

            <div class="content-area">
                <div class="input-section">
                    <h2>📄 Input Transcript</h2>
                    <textarea 
                        id="transcriptInput" 
                        class="transcript-input" 
                        placeholder="Enter your daily transcript or conversation logs here..."
                    ></textarea>
                    
                    <button id="processAllButton" class="process-button" disabled>
                        🚀 Process All Prompts
                    </button>
                    
                    <div id="progressSection" style="display: none;">
                        <div class="progress-bar">
                            <div id="progressFill" class="progress-fill"></div>
                        </div>
                        <div id="statusText" class="status-text"></div>
                    </div>
                </div>

                <div class="results-section">
                    <h2>📊 Results</h2>
                    <div id="resultsContainer">
                        <div class="no-results">
                            No results yet. Process your transcript to see the analysis.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="individual-prompts">
            <h3>🎯 Process Individual Prompts</h3>
            <div id="individualPrompts">
                <!-- Individual prompt buttons will be populated here -->
            </div>
        </div>

        <div class="footer">
            Made with ❤️ for daily productivity analysis | Powered by Google Gemini AI
        </div>
    </div>

    <!-- Prompt Editor Modal -->
    <div id="promptEditorModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle" class="modal-title">Edit Prompt</h2>
                <button id="modalClose" class="modal-close" type="button">&times;</button>
            </div>
            <div class="modal-body">
                <form id="promptEditorForm">
                    <div class="form-group">
                        <label for="promptName" class="form-label">Prompt Name</label>
                        <input 
                            type="text" 
                            id="promptName" 
                            class="form-input" 
                            placeholder="Enter a descriptive name for this prompt"
                            required
                        >
                        <div id="nameError" class="error-message">Please enter a prompt name</div>
                        <div class="form-help">This name will appear in tabs and the processing list</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="promptContent" class="form-label">Prompt Content</label>
                        <textarea 
                            id="promptContent" 
                            class="form-textarea" 
                            placeholder="Enter the full prompt text that will be sent to the AI model..."
                            required
                        ></textarea>
                        <div id="contentError" class="error-message">Please enter prompt content</div>
                        <div class="character-counter" id="characterCounter">0 characters</div>
                        <div class="form-help">
                            This is the instruction text that will be sent to the AI model. 
                            Use clear, specific instructions for best results.
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" id="cancelButton" class="modal-button modal-button-secondary">
                    Cancel
                </button>
                <button type="submit" id="saveButton" class="modal-button modal-button-primary" form="promptEditorForm">
                    Save Prompt
                </button>
            </div>
        </div>
    </div>

    <script>
        // Configuration and state
        const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
        const ROTATION_STORAGE_KEY = 'gemini_auto_rotate_settings';
        const MODEL_STORAGE_KEY = 'gemini_selected_model';
        
        // Model configurations
        const MODELS = {
            'gemini-2.5-pro': {
                name: 'Gemini 2.5 Pro',
                capabilities: 'Audio, images, videos, text, and PDF',
                output: 'Text',
                description: 'Enhanced thinking and reasoning, multimodal understanding, advanced coding, and more',
                badges: ['premium', 'multimodal'],
                recommended: 'Best for complex analysis and reasoning tasks'
            },
            'gemini-2.5-flash': {
                name: 'Gemini 2.5 Flash',
                capabilities: 'Audio, images, videos, and text',
                output: 'Text',
                description: 'Adaptive thinking, cost efficiency',
                badges: ['fast', 'balanced'],
                recommended: 'Great balance of speed and capability'
            },
            'gemini-2.5-flash-lite': {
                name: 'Gemini 2.5 Flash-Lite',
                capabilities: 'Text',
                output: 'Text',
                description: 'Lightweight and fast processing',
                badges: ['lite', 'fast'],
                recommended: 'Fastest processing for text-only tasks'
            }
        };
        
        let state = {
            apiKey: '',
            responses: {},
            processing: false,
            autoRotate: false,
            currentRotationIndex: 0,
            availableKeys: [],
            selectedModel: 'gemini-2.5-pro',
            lastTranscript: ''
        };

        // Default prompts configuration with metadata
        const DEFAULT_PROMPTS = {
            "highlights_reflection": {
                "name": "📌 Highlights and Reflections",
                "prompt": `Give me these points with quotes:
- Highlights of the Day:
- Areas for Improvement:
- Reflections/Thoughts:
- Small things that bring you joy throughout the day`,
                "enabled": true,
                "isDefault": true,
                "order": 1
            },
            
            "todo_list": {
                "name": "📝 To-Do List",
                "prompt": `I need a comprehensive to-do list based on my conversation transcripts. Please analyze the transcript and identify all tasks, commitments, and follow-up actions I mentioned or agreed to.

Importantly: Only use items that I specifically said I would do. Do not include things other people said they would do.

For each item, include enough detail that I can understand what needs to be done without having to review the entire transcript again. Use action verbs at the beginning of each task.

Group related tasks together when possible, and highlight any dependencies between tasks (e.g., "Complete X before starting Y").

Exclude routine activities or general comments that don't require specific action.`,
                "enabled": true,
                "isDefault": true,
                "order": 2
            },
            
            "daily_chart": {
                "name": "📊 Daily Activity Chart",
                "prompt": `Analyze my day and present the results in exactly this format:

## 📊 Pie Chart-Style Analysis (Text Representation)
Create a visual bar representation using block characters (█ and ░) showing each category with:
- Duration in ~Xh Ym format
- Percentage of total day in parentheses
- Bar length proportional to time spent
- Ordered by duration (longest to shortest)

Format example:
\`\`\`
🧠 Deep Work ███████████████░░░░░░░░░░ ~4h15m (17.7%)
🤝 Work Conversations █████████░░░░░░░░░░░░░░░ ~2h10m (9.0%)
\`\`\`

## 🧩 Activity Breakdown by Category
Present activities in a clean table format with the following specifications:

**Formatting Requirements:**
- Use consistent emoji icons for each category type
- Order categories by total duration (longest to shortest)
- Include percentage of total day for each category
- Use standardized time format (~Xh Ym for hours/minutes, ~Xm for minutes only)
- Limit highlights to 2-3 key points per category, separated by semicolons
- Use consistent category naming conventions

**Standard Categories (use these when applicable):**
- 🧠 Deep Work - focused, productive work tasks
- 🤝 Work Conversations - meetings, discussions, collaboration
- 🍛 Meals & Socializing - eating, social interactions, personal conversations
- 🚃 Travel & Commute - all transportation and movement
- 🎓 Learning & Development - educational content, skill building
- 🤖 Personal Admin - household tasks, personal management, errands
- 💤 Rest & Downtime - breaks, relaxation, entertainment
- 🏃 Health & Fitness - exercise, health-related activities

**Table Format:**
\`\`\`
| Category | Duration (% of day) | Highlights |
|----------|---------------------|------------|
| [emoji] [Category Name] | ~[Time] ([X.X%]) | [Key activities; separated by semicolons] |
\`\`\``,
                "enabled": true,
                "isDefault": true,
                "order": 3
            },
            
            "suggestion": {
                "name": "💡 Personal Improvement Suggestions",
                "prompt": `My goal is to be better on every dimension of my life: personal, work, and family. Give me one concrete thing I could do to be better using these conversations by focusing on what I said and how I responded to the people in my life. Support this one concrete way I can be better with several examples to help me identify patterns I might not realize. Be candid.

If prior responses are included:
- Remind the user of what they've been working on in a single sentence at the top of the response.
- Ensure that the response is consistent with the prior responses; but, if you notice positive growth, acknowledge it!
- Gently remind the user of past feedback if it's relevant to the current response, but in a positive way - for example, "It's great that you've been working on x goal!"
- When you make assertive recommendations, reference prior feedback - say something like "You've already been working on this goal, keep it up!" for each goal or piece of feedback from prior responses. Share this early, so the user can see that you've been paying attention to their progress.`,
                "enabled": true,
                "isDefault": true,
                "order": 4
            },
            
            "summary": {
                "name": "📋 Day Summary",
                "prompt": `I need a summary of my day based on my conversation transcripts from yesterday. Look at the transcript and respond with a summary of my day that I can use to review everything that happened quickly.

Here are the things I want to be included in the summary:
- Key meetings and conversations I participated in
- Important information I learned or shared
- Decisions I made or was involved in
- Problems I encountered and solutions I found
- Major themes or patterns in my conversations

Format the summary to be readable and insightful, highlighting what matters most about my day. Keep it brief but comprehensive, capturing the essence of my experiences rather than listing every detail.

Show me the summary in chronological order when possible, starting with morning activities and ending with evening ones. Prioritize significant events over routine interactions.`,
                "enabled": true,
                "isDefault": true,
                "order": 5
            },
            
            "daily_logs": {
                "name": "📖 Structured Daily Logs",
                "prompt": `You are an expert summarizer who creates a **highly structured, factual, and detailed log of daily events** from transcripts. The following is a daily transcript from my Limitless Pendant. Your main goal is to create the most comprehensive set of **objective notes** about the daily events and conversations in chronological order. The output should be a **multi-level bulleted list**, not a narrative story. The tone should be factual and easily scannable, like an executive summary or a detailed activity log.

**Formatting Instructions:**
- Create your own markdown headings for major events (e.g., "Morning Routine," "School BBQ").
- Under these headings, use bolded sub-headings for more specific time blocks or interactions (e.g., "****Daycare Pick-up:****").
- Insert timestamps or time ranges in the headings and sub-headings.
- Under each sub-heading, use **concise bullet points** to list the key facts, actions, and conversation topics.
- **Use parentheses () to add clarifying details**, such as names of people mentioned (e.g., talked with John (Kim's father)), specific costs ($5), or contextual notes (as you had correctly guessed).
- At the beginning of the document, insert "Daily Summary <insert date in YYYY-MM-DD format>" in Header 1 size.

**Content and Interpretation Instructions:**
- Accurately infer events and the main topics of conversations.
- Summarize conversations by focusing on the **key points and outcomes**, rather than quoting long exchanges.
- Note that on occasion, you may see an unknown speaker identified, either as "Unknown" or "Speaker 1", "Speaker 2" etc.
- Transcription errors may also create non-sensical transcriptions. When your interpretation is considered to be highly suspect due to nonsensical statements, make an explicit note that the original audio recording should be reviewed.
- When summarizing, you will need to consider speaker misattribution errors alongside transcription errors. Where possible, correct the speaker attribution based on the context of the conversation.

Transcript follows:`,
                "enabled": true,
                "isDefault": true,
                "order": 6
            },
            
            "new_learning": {
                "name": "🎓 New Learning Points",
                "prompt": `✍️ Please analyze the following transcribed conversation and extract all learning points, including:

🧠 New Vocabulary – List any unfamiliar or newly learned Japanese or English words. Include:
- Word/Phrase
- Language (🇯🇵/🇬🇧)
- Meaning/Translation
- Example sentence (based on conversation or create one)

📘 New Concepts or Terms – Summarize any new concepts, professional terminology, or ideas that came up. Include:
- Term/Concept
- Short explanation in plain language
- Context or example from the conversation

🔁 Corrections/Better Expressions – If there were any grammar mistakes or unnatural expressions, show the corrected versions with explanations.

✨ Summary Memo – End with a short memo (in natural language) summarizing everything I learned today in a casual, reflective tone.`,
                "enabled": true,
                "isDefault": true,
                "order": 7
            }
        };

        // Working prompts (will be populated from localStorage or defaults)
        let PROMPTS = {};

        // Modal state
        let currentEditingKey = null;
        let isNewPrompt = false;

        // DOM Elements
        const modelSelector = document.getElementById('modelSelector');
        const modelInfo = document.getElementById('modelInfo');
        const promptList = document.getElementById('promptList');
        const addPromptButton = document.getElementById('addPromptButton');
        const resetAllPromptsButton = document.getElementById('resetAllPromptsButton');
        const exportPromptsButton = document.getElementById('exportPromptsButton');
        const importPromptsButton = document.getElementById('importPromptsButton');
        const importPromptsFileInput = document.getElementById('importPromptsFileInput');
        const processingOrder = document.getElementById('processingOrder');
        
        // Modal Elements
        const promptEditorModal = document.getElementById('promptEditorModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalClose = document.getElementById('modalClose');
        const promptEditorForm = document.getElementById('promptEditorForm');
        const promptNameInput = document.getElementById('promptName');
        const promptContentInput = document.getElementById('promptContent');
        const nameError = document.getElementById('nameError');
        const contentError = document.getElementById('contentError');
        const characterCounter = document.getElementById('characterCounter');
        const cancelButton = document.getElementById('cancelButton');
        const saveButton = document.getElementById('saveButton');
        
        const apiKeyInput = document.getElementById('apiKey');
        const apiKeySelector = document.getElementById('apiKeySelector');
        const apiKeyLabel = document.getElementById('apiKeyLabel');
        const saveApiKeyButton = document.getElementById('saveApiKeyButton');
        const deleteApiKeyButton = document.getElementById('deleteApiKeyButton');
        const autoRotateToggle = document.getElementById('autoRotateToggle');
        const currentApiIndicator = document.getElementById('currentApiIndicator');
        const currentApiLabel = document.getElementById('currentApiLabel');
        const exportKeysButton = document.getElementById('exportKeysButton');
        const importKeysButton = document.getElementById('importKeysButton');
        const importFileInput = document.getElementById('importFileInput');
        const apiStatus = document.getElementById('apiStatus');
        const transcriptInput = document.getElementById('transcriptInput');
        const processAllButton = document.getElementById('processAllButton');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const resultsContainer = document.getElementById('resultsContainer');
        const individualPrompts = document.getElementById('individualPrompts');

        // Modal Management Functions
        function openModal(key = null) {
            currentEditingKey = key;
            isNewPrompt = !key;
            
            if (isNewPrompt) {
                modalTitle.textContent = 'Add New Prompt';
                promptNameInput.value = '';
                promptContentInput.value = '';
                saveButton.textContent = 'Add Prompt';
            } else {
                modalTitle.textContent = 'Edit Prompt';
                const prompt = PROMPTS[key];
                promptNameInput.value = prompt.name;
                promptContentInput.value = prompt.prompt;
                saveButton.textContent = 'Save Changes';
            }
            
            // Clear any error states
            clearErrors();
            updateCharacterCounter();
            
            // Show modal
            promptEditorModal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Focus on name input
            setTimeout(() => {
                promptNameInput.focus();
                promptNameInput.select();
            }, 100);
        }

        function closeModal() {
            promptEditorModal.classList.remove('active');
            document.body.style.overflow = '';
            currentEditingKey = null;
            isNewPrompt = false;
            
            // Clear form
            promptNameInput.value = '';
            promptContentInput.value = '';
            clearErrors();
            updateCharacterCounter();
        }

        function clearErrors() {
            nameError.classList.remove('visible');
            contentError.classList.remove('visible');
            promptNameInput.style.borderColor = '';
            promptContentInput.style.borderColor = '';
        }

        function showError(field, message) {
            if (field === 'name') {
                nameError.textContent = message;
                nameError.classList.add('visible');
                promptNameInput.style.borderColor = '#d32f2f';
            } else if (field === 'content') {
                contentError.textContent = message;
                contentError.classList.add('visible');
                promptContentInput.style.borderColor = '#d32f2f';
            }
        }

        function validateForm() {
            clearErrors();
            let isValid = true;
            
            const name = promptNameInput.value.trim();
            const content = promptContentInput.value.trim();
            
            if (!name) {
                showError('name', 'Please enter a prompt name');
                isValid = false;
            } else if (name.length < 3) {
                showError('name', 'Prompt name must be at least 3 characters');
                isValid = false;
            } else if (name.length > 50) {
                showError('name', 'Prompt name must be less than 50 characters');
                isValid = false;
            }
            
            if (!content) {
                showError('content', 'Please enter prompt content');
                isValid = false;
            } else if (content.length < 10) {
                showError('content', 'Prompt content must be at least 10 characters');
                isValid = false;
            }
            
            // Check for duplicate names (except when editing the same prompt)
            if (name && isValid) {
                const existingKey = Object.keys(PROMPTS).find(key => 
                    PROMPTS[key].name.toLowerCase() === name.toLowerCase() && 
                    key !== currentEditingKey
                );
                if (existingKey) {
                    showError('name', 'A prompt with this name already exists');
                    isValid = false;
                }
            }
            
            return isValid;
        }

        function updateCharacterCounter() {
            const count = promptContentInput.value.length;
            characterCounter.textContent = `${count} characters`;
            
            if (count > 2000) {
                characterCounter.style.color = '#f57c00';
            } else if (count > 1500) {
                characterCounter.style.color = '#ff9800';
            } else {
                characterCounter.style.color = '#999';
            }
        }

        function handleModalSubmit(e) {
            e.preventDefault();
            
            if (!validateForm()) return;
            
            const name = promptNameInput.value.trim();
            const content = promptContentInput.value.trim();
            
            if (isNewPrompt) {
                const newKey = addCustomPrompt({ name, prompt: content });
                showApiStatus(`✅ Added new prompt "${name}"`, 'success');
            } else {
                updatePrompt(currentEditingKey, { name, prompt: content });
                showApiStatus(`✅ Updated prompt "${name}"`, 'success');
            }
            
            renderPromptList();
            updateProcessingOrder();
            setupIndividualPrompts();
            closeModal();
        }

        // Model Management
        function loadSelectedModel() {
            const saved = localStorage.getItem(MODEL_STORAGE_KEY);
            return saved || 'gemini-2.5-pro';
        }

        function saveSelectedModel() {
            localStorage.setItem(MODEL_STORAGE_KEY, state.selectedModel);
        }

        function handleModelSelection() {
            state.selectedModel = modelSelector.value;
            saveSelectedModel();
            updateModelInfo();
            showApiStatus(`✅ Model changed to ${MODELS[state.selectedModel].name}`, 'success');
        }

        function updateModelInfo() {
            const model = MODELS[state.selectedModel];
            if (!model) return;

            const badges = model.badges.map(badge => 
                `<span class="model-badge ${badge}">${badge.toUpperCase()}</span>`
            ).join('');

            modelInfo.innerHTML = `
                <div class="model-name">${model.name}</div>
                <div style="margin-bottom: 8px;">${badges}</div>
                <div class="model-capabilities"><strong>Input:</strong> ${model.capabilities}</div>
                <div class="model-capabilities"><strong>Output:</strong> ${model.output}</div>
                <div class="model-description">${model.description}</div>
                <div style="margin-top: 8px; color: #007bff; font-size: 11px;">
                    💡 ${model.recommended}
                </div>
            `;
        }

        // Storage Keys
        const STORAGE_KEY = 'gemini_api_keys';
        const PROMPTS_STORAGE_KEY = 'gemini_custom_prompts';

        // Prompt Management Functions
        function loadCustomPrompts() {
            const saved = localStorage.getItem(PROMPTS_STORAGE_KEY);
            return saved ? JSON.parse(saved) : {};
        }

        function saveCustomPrompts() {
            localStorage.setItem(PROMPTS_STORAGE_KEY, JSON.stringify(PROMPTS));
        }

        function initializePrompts() {
            const customPrompts = loadCustomPrompts();
            
            // Start with defaults
            PROMPTS = JSON.parse(JSON.stringify(DEFAULT_PROMPTS));
            
            // Merge with custom prompts
            Object.keys(customPrompts).forEach(key => {
                if (customPrompts[key]) {
                    PROMPTS[key] = { ...PROMPTS[key], ...customPrompts[key] };
                }
            });
            
            // Add any custom prompts that don't exist in defaults
            Object.keys(customPrompts).forEach(key => {
                if (!PROMPTS[key] && customPrompts[key]) {
                    PROMPTS[key] = customPrompts[key];
                }
            });
        }

        function getEnabledPrompts() {
            const enabled = {};
            Object.keys(PROMPTS).forEach(key => {
                if (PROMPTS[key].enabled) {
                    enabled[key] = PROMPTS[key];
                }
            });
            return enabled;
        }

        function getOrderedPrompts() {
            return Object.entries(PROMPTS)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999))
                .reduce((obj, [key, value]) => {
                    obj[key] = value;
                    return obj;
                }, {});
        }

        function togglePrompt(key, enabled) {
            if (PROMPTS[key]) {
                PROMPTS[key].enabled = enabled;
                saveCustomPrompts();
                updateProcessingOrder();
            }
        }

        function deletePrompt(key) {
            if (PROMPTS[key] && !PROMPTS[key].isDefault) {
                delete PROMPTS[key];
                saveCustomPrompts();
                updateProcessingOrder();
                return true;
            }
            return false;
        }

        function resetPromptToDefault(key) {
            if (DEFAULT_PROMPTS[key]) {
                PROMPTS[key] = JSON.parse(JSON.stringify(DEFAULT_PROMPTS[key]));
                saveCustomPrompts();
                return true;
            }
            return false;
        }

        function resetAllPromptsToDefault() {
            PROMPTS = JSON.parse(JSON.stringify(DEFAULT_PROMPTS));
            saveCustomPrompts();
            updateProcessingOrder();
        }

        function addCustomPrompt(promptData) {
            const key = generatePromptKey(promptData.name);
            PROMPTS[key] = {
                name: promptData.name,
                prompt: promptData.prompt,
                enabled: true,
                isDefault: false,
                order: getNextOrder()
            };
            saveCustomPrompts();
            updateProcessingOrder();
            return key;
        }

        function updatePrompt(key, promptData) {
            if (PROMPTS[key]) {
                PROMPTS[key].name = promptData.name;
                PROMPTS[key].prompt = promptData.prompt;
                saveCustomPrompts();
                return true;
            }
            return false;
        }

        function generatePromptKey(name) {
            const base = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
            let key = base;
            let counter = 1;
            
            while (PROMPTS[key]) {
                key = `${base}_${counter}`;
                counter++;
            }
            
            return key;
        }

        function getNextOrder() {
            const maxOrder = Math.max(...Object.values(PROMPTS).map(p => p.order || 0));
            return maxOrder + 1;
        }

        // Prompt Export/Import Functions
        function exportPrompts() {
            const exportData = {
                version: "1.0",
                exportDate: new Date().toISOString(),
                promptCount: Object.keys(PROMPTS).length,
                prompts: PROMPTS
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `prompts_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showApiStatus(`✅ Exported ${exportData.promptCount} prompts successfully!`, 'success');
        }

        function validatePromptImportData(data) {
            if (typeof data !== 'object' || data === null) {
                throw new Error('Invalid JSON format');
            }
            
            if (!data.prompts || typeof data.prompts !== 'object') {
                throw new Error('Missing or invalid prompts field');
            }
            
            // Validate each prompt
            Object.entries(data.prompts).forEach(([key, prompt]) => {
                if (!prompt.name || typeof prompt.name !== 'string') {
                    throw new Error(`Invalid prompt name for key: "${key}"`);
                }
                if (!prompt.prompt || typeof prompt.prompt !== 'string') {
                    throw new Error(`Invalid prompt content for: "${prompt.name}"`);
                }
            });
            
            return true;
        }

        function importPrompts(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    // Validate the imported data
                    validatePromptImportData(importData);
                    
                    const importedCount = Object.keys(importData.prompts).length;
                    const customPromptsCount = Object.values(importData.prompts).filter(p => !p.isDefault).length;
                    const defaultPromptsCount = Object.values(importData.prompts).filter(p => p.isDefault).length;
                    
                    const confirmMessage = `Import ${importedCount} prompts?\n` +
                        `• ${defaultPromptsCount} default prompts (will replace current defaults)\n` +
                        `• ${customPromptsCount} custom prompts\n\n` +
                        `This will replace all your current prompts.`;
                    
                    if (confirm(confirmMessage)) {
                        // Import all prompts
                        PROMPTS = importData.prompts;
                        
                        // Ensure orders are set
                        let maxOrder = 0;
                        Object.values(PROMPTS).forEach(prompt => {
                            if (!prompt.order) {
                                prompt.order = ++maxOrder;
                            } else {
                                maxOrder = Math.max(maxOrder, prompt.order);
                            }
                        });
                        
                        // Save and refresh UI
                        saveCustomPrompts();
                        renderPromptList();
                        updateProcessingOrder();
                        setupIndividualPrompts();
                        
                        showApiStatus(`✅ Successfully imported ${importedCount} prompts!`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    showApiStatus(`❌ Import failed: ${error.message}`, 'error');
                }
            };
            
            reader.onerror = function() {
                showApiStatus('❌ Failed to read file', 'error');
            };
            
            reader.readAsText(file);
        }

        function renderPromptList() {
            const orderedPrompts = getOrderedPrompts();
            promptList.innerHTML = '';
            
            Object.entries(orderedPrompts).forEach(([key, prompt]) => {
                const promptItem = document.createElement('div');
                promptItem.className = `prompt-item ${!prompt.enabled ? 'disabled' : ''}`;
                
                const toggle = document.createElement('div');
                toggle.className = 'prompt-toggle';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = prompt.enabled;
                checkbox.addEventListener('change', (e) => {
                    togglePrompt(key, e.target.checked);
                    renderPromptList();
                    updateProcessingOrder();
                });
                toggle.appendChild(checkbox);
                
                const details = document.createElement('div');
                details.className = 'prompt-details';
                
                const name = document.createElement('div');
                name.className = 'prompt-name';
                name.textContent = prompt.name;
                
                const meta = document.createElement('div');
                meta.className = 'prompt-meta';
                
                const badge = document.createElement('span');
                badge.className = `prompt-badge ${prompt.isDefault ? '' : 'custom'}`;
                badge.textContent = prompt.isDefault ? 'DEFAULT' : 'CUSTOM';
                
                const order = document.createElement('span');
                order.textContent = `Order: ${prompt.order || 999}`;
                
                meta.appendChild(badge);
                meta.appendChild(order);
                details.appendChild(name);
                details.appendChild(meta);
                
                const controls = document.createElement('div');
                controls.className = 'prompt-controls';
                
                // Edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'prompt-control-btn edit-btn';
                editBtn.textContent = '✏️';
                editBtn.title = 'Edit';
                editBtn.addEventListener('click', () => openPromptEditor(key));
                
                // Duplicate button
                const duplicateBtn = document.createElement('button');
                duplicateBtn.className = 'prompt-control-btn duplicate-btn';
                duplicateBtn.textContent = '📋';
                duplicateBtn.title = 'Duplicate';
                duplicateBtn.addEventListener('click', () => duplicatePrompt(key));
                
                // Reset button (only for default prompts)
                if (prompt.isDefault) {
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'prompt-control-btn reset-btn';
                    resetBtn.textContent = '🔄';
                    resetBtn.title = 'Reset to Default';
                    resetBtn.addEventListener('click', () => {
                        if (confirm(`Reset "${prompt.name}" to default?`)) {
                            resetPromptToDefault(key);
                            renderPromptList();
                            updateProcessingOrder();
                            showApiStatus(`✅ Reset "${prompt.name}" to default`, 'success');
                        }
                    });
                    controls.appendChild(resetBtn);
                }
                
                // Delete button (only for custom prompts)
                if (!prompt.isDefault) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'prompt-control-btn delete-btn';
                    deleteBtn.textContent = '🗑️';
                    deleteBtn.title = 'Delete';
                    deleteBtn.addEventListener('click', () => {
                        if (confirm(`Delete "${prompt.name}"? This cannot be undone.`)) {
                            if (deletePrompt(key)) {
                                renderPromptList();
                                updateProcessingOrder();
                                showApiStatus(`✅ Deleted "${prompt.name}"`, 'success');
                            }
                        }
                    });
                    controls.appendChild(deleteBtn);
                }
                
                controls.appendChild(editBtn);
                controls.appendChild(duplicateBtn);
                
                promptItem.appendChild(toggle);
                promptItem.appendChild(details);
                promptItem.appendChild(controls);
                promptList.appendChild(promptItem);
            });
        }

        function updateProcessingOrder() {
            const enabledPrompts = getEnabledPrompts();
            const orderedPrompts = Object.entries(enabledPrompts)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999));
            
            processingOrder.innerHTML = '';
            orderedPrompts.forEach(([key, prompt], index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${prompt.name}`;
                processingOrder.appendChild(li);
            });
            
            if (orderedPrompts.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No prompts enabled';
                li.style.fontStyle = 'italic';
                li.style.color = '#999';
                processingOrder.appendChild(li);
            }
            
            // Update export button state
            exportPromptsButton.disabled = Object.keys(PROMPTS).length === 0;
        }

        function duplicatePrompt(sourceKey) {
            const sourcePrompt = PROMPTS[sourceKey];
            if (!sourcePrompt) return;
            
            const newName = `${sourcePrompt.name} (Copy)`;
            const key = addCustomPrompt({
                name: newName,
                prompt: sourcePrompt.prompt
            });
            
            renderPromptList();
            showApiStatus(`✅ Duplicated "${sourcePrompt.name}"`, 'success');
            
            // Open editor for the new prompt
            setTimeout(() => openPromptEditor(key), 100);
        }

        // Updated prompt editor using the modal
        function openPromptEditor(key = null) {
            openModal(key);
        }

        // API Key Management
        function loadSavedApiKeys() {
            const saved = localStorage.getItem(STORAGE_KEY);
            return saved ? JSON.parse(saved) : {};
        }

        function loadRotationSettings() {
            const saved = localStorage.getItem(ROTATION_STORAGE_KEY);
            return saved ? JSON.parse(saved) : { autoRotate: false, currentIndex: 0 };
        }

        function saveRotationSettings() {
            const settings = {
                autoRotate: state.autoRotate,
                currentIndex: state.currentRotationIndex
            };
            localStorage.setItem(ROTATION_STORAGE_KEY, JSON.stringify(settings));
        }

        function updateAvailableKeys() {
            const apiKeys = loadSavedApiKeys();
            state.availableKeys = Object.entries(apiKeys).map(([label, key]) => ({
                label,
                key
            }));
            
            // Reset rotation index if it's out of bounds
            if (state.currentRotationIndex >= state.availableKeys.length) {
                state.currentRotationIndex = 0;
            }
        }

        function getNextApiKey() {
            if (!state.autoRotate || state.availableKeys.length === 0) {
                return state.apiKey;
            }
            
            if (state.availableKeys.length === 1) {
                return state.availableKeys[0].key;
            }
            
            const currentKey = state.availableKeys[state.currentRotationIndex];
            
            // Rotate to next key for the next request
            state.currentRotationIndex = (state.currentRotationIndex + 1) % state.availableKeys.length;
            saveRotationSettings();
            
            // Update UI to show current key
            updateCurrentApiIndicator(currentKey.label);
            
            return currentKey.key;
        }

        function updateCurrentApiIndicator(label) {
            if (state.autoRotate && label) {
                currentApiLabel.textContent = label;
                currentApiIndicator.style.display = 'block';
            } else {
                currentApiIndicator.style.display = 'none';
            }
        }

        function saveApiKeys(apiKeys) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(apiKeys));
        }

        function populateApiKeySelector() {
            const apiKeys = loadSavedApiKeys();
            apiKeySelector.innerHTML = '<option value="">Select saved API key...</option>';
            
            Object.entries(apiKeys).forEach(([label, key]) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = label;
                apiKeySelector.appendChild(option);
            });
            
            updateAvailableKeys();
            updateAutoRotateUI();
        }

        function saveCurrentApiKey() {
            const key = apiKeyInput.value.trim();
            const label = apiKeyLabel.value.trim();
            
            if (!key || !label) return;
            
            const apiKeys = loadSavedApiKeys();
            apiKeys[label] = key;
            saveApiKeys(apiKeys);
            
            populateApiKeySelector();
            apiKeySelector.value = key;
            apiKeyLabel.value = '';
            
            showApiStatus(`✅ API key "${label}" saved successfully!`, 'success');
            updateUI();
        }

        function deleteSelectedApiKey() {
            const selectedKey = apiKeySelector.value;
            if (!selectedKey) return;
            
            const apiKeys = loadSavedApiKeys();
            const labelToDelete = Object.keys(apiKeys).find(label => apiKeys[label] === selectedKey);
            
            if (labelToDelete) {
                delete apiKeys[labelToDelete];
                saveApiKeys(apiKeys);
                populateApiKeySelector();
                
                if (state.apiKey === selectedKey) {
                    state.apiKey = '';
                    apiKeyInput.value = '';
                }
                
                showApiStatus(`✅ API key "${labelToDelete}" deleted successfully!`, 'success');
                updateUI();
            }
        }

        function showApiStatus(message, type) {
            apiStatus.textContent = message;
            apiStatus.className = `status ${type}`;
            apiStatus.style.display = 'block';
            
            setTimeout(() => {
                apiStatus.style.display = 'none';
            }, 3000);
        }

        function handleAutoRotateToggle() {
            state.autoRotate = autoRotateToggle.checked;
            saveRotationSettings();
            updateAutoRotateUI();
            
            if (state.autoRotate) {
                showApiStatus('✅ Auto-rotation enabled', 'success');
            } else {
                showApiStatus('ℹ️ Auto-rotation disabled', 'success');
            }
        }

        function updateAutoRotateUI() {
            const hasMultipleKeys = state.availableKeys.length > 1;
            
            // Disable toggle if less than 2 keys
            autoRotateToggle.disabled = !hasMultipleKeys;
            
            if (!hasMultipleKeys && state.autoRotate) {
                state.autoRotate = false;
                autoRotateToggle.checked = false;
                saveRotationSettings();
            }
            
            // Update current API indicator
            if (state.autoRotate && hasMultipleKeys) {
                const nextKey = state.availableKeys[state.currentRotationIndex];
                updateCurrentApiIndicator(nextKey ? nextKey.label : '');
            } else {
                updateCurrentApiIndicator('');
            }
        }

        // Import/Export Functions
        function exportApiKeys() {
            const apiKeys = loadSavedApiKeys();
            const rotationSettings = loadRotationSettings();
            const customPrompts = loadCustomPrompts();
            
            const exportData = {
                version: "1.1",
                exportDate: new Date().toISOString(),
                apiKeys: apiKeys,
                rotationSettings: rotationSettings,
                selectedModel: state.selectedModel,
                customPrompts: customPrompts
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `gemini_config_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showApiStatus(`✅ Configuration exported successfully!`, 'success');
        }

        function validateImportData(data) {
            // Check if it's a valid object
            if (typeof data !== 'object' || data === null) {
                throw new Error('Invalid JSON format');
            }
            
            // Check for required fields
            if (!data.apiKeys || typeof data.apiKeys !== 'object') {
                throw new Error('Missing or invalid apiKeys field');
            }
            
            // Validate each API key entry
            Object.entries(data.apiKeys).forEach(([label, key]) => {
                if (typeof label !== 'string' || label.trim() === '') {
                    throw new Error(`Invalid label: "${label}"`);
                }
                if (typeof key !== 'string' || key.trim() === '') {
                    throw new Error(`Invalid API key for label: "${label}"`);
                }
            });
            
            return true;
        }

        function importApiKeys(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    // Validate the imported data
                    validateImportData(importData);
                    
                    // Ask user for confirmation
                    const keyCount = Object.keys(importData.apiKeys).length;
                    const confirmMessage = `Import ${keyCount} API keys? This will merge with existing keys (duplicates will be overwritten).`;
                    
                    if (confirm(confirmMessage)) {
                        // Merge with existing API keys
                        const existingKeys = loadSavedApiKeys();
                        const mergedKeys = { ...existingKeys, ...importData.apiKeys };
                        
                        // Save merged keys
                        saveApiKeys(mergedKeys);
                        
                        // Import rotation settings if available
                        if (importData.rotationSettings && 
                            typeof importData.rotationSettings === 'object') {
                            state.autoRotate = importData.rotationSettings.autoRotate || false;
                            state.currentRotationIndex = importData.rotationSettings.currentIndex || 0;
                            autoRotateToggle.checked = state.autoRotate;
                            saveRotationSettings();
                        }
                        
                        // Import model selection if available
                        if (importData.selectedModel && 
                            MODELS[importData.selectedModel]) {
                            state.selectedModel = importData.selectedModel;
                            modelSelector.value = state.selectedModel;
                            saveSelectedModel();
                            updateModelInfo();
                        }
                        
                        // Import custom prompts if available
                        if (importData.customPrompts && 
                            typeof importData.customPrompts === 'object') {
                            
                            // Save the custom prompts and reinitialize
                            localStorage.setItem(PROMPTS_STORAGE_KEY, JSON.stringify(importData.customPrompts));
                            initializePrompts();
                            
                            // Refresh prompt-related UI
                            renderPromptList();
                            updateProcessingOrder();
                            setupIndividualPrompts();
                        }
                        
                        // Refresh UI
                        populateApiKeySelector();
                        updateUI();
                        
                        const promptCount = importData.customPrompts ? 
                            Object.keys(importData.customPrompts).length : 0;
                        const message = promptCount > 0 ? 
                            `✅ Successfully imported ${keyCount} API keys and ${promptCount} custom prompts!` :
                            `✅ Successfully imported configuration with ${keyCount} API keys!`;
                        
                        showApiStatus(message, 'success');
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    showApiStatus(`❌ Import failed: ${error.message}`, 'error');
                }
            };
            
            reader.onerror = function() {
                showApiStatus('❌ Failed to read file', 'error');
            };
            
            reader.readAsText(file);
        }

        // Initialize the application
        function init() {
            // Initialize prompts first
            initializePrompts();
            
            // Load saved settings
            state.selectedModel = loadSelectedModel();
            modelSelector.value = state.selectedModel;
            updateModelInfo();
            
            const rotationSettings = loadRotationSettings();
            state.autoRotate = rotationSettings.autoRotate;
            state.currentRotationIndex = rotationSettings.currentIndex;
            autoRotateToggle.checked = state.autoRotate;
            
            setupEventListeners();
            renderPromptList();
            updateProcessingOrder();
            setupIndividualPrompts();
            populateApiKeySelector();
            updateUI();
        }

        function setupEventListeners() {
            modelSelector.addEventListener('change', handleModelSelection);
            addPromptButton.addEventListener('click', () => openPromptEditor());
            resetAllPromptsButton.addEventListener('click', () => {
                if (confirm('Reset all prompts to defaults? This will remove all custom prompts and reset all modifications.')) {
                    resetAllPromptsToDefault();
                    renderPromptList();
                    updateProcessingOrder();
                    setupIndividualPrompts();
                    showApiStatus('✅ All prompts reset to defaults', 'success');
                }
            });
            
            // Prompt export/import event listeners
            exportPromptsButton.addEventListener('click', exportPrompts);
            importPromptsButton.addEventListener('click', () => importPromptsFileInput.click());
            importPromptsFileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    importPrompts(e.target.files[0]);
                    // Reset file input so the same file can be selected again
                    e.target.value = '';
                }
            });
            
            // Modal event listeners
            modalClose.addEventListener('click', closeModal);
            cancelButton.addEventListener('click', closeModal);
            promptEditorForm.addEventListener('submit', handleModalSubmit);
            promptContentInput.addEventListener('input', updateCharacterCounter);
            
            // Close modal on backdrop click
            promptEditorModal.addEventListener('click', (e) => {
                if (e.target === promptEditorModal) {
                    closeModal();
                }
            });
            
            // Keyboard shortcuts for modal
            document.addEventListener('keydown', (e) => {
                if (promptEditorModal.classList.contains('active')) {
                    if (e.key === 'Escape') {
                        closeModal();
                    } else if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        handleModalSubmit(new Event('submit'));
                    }
                }
            });
            
            apiKeyInput.addEventListener('input', handleApiKeyChange);
            apiKeySelector.addEventListener('change', handleApiKeySelection);
            apiKeyLabel.addEventListener('input', updateUI);
            saveApiKeyButton.addEventListener('click', saveCurrentApiKey);
            deleteApiKeyButton.addEventListener('click', deleteSelectedApiKey);
            autoRotateToggle.addEventListener('change', handleAutoRotateToggle);
            exportKeysButton.addEventListener('click', exportApiKeys);
            importKeysButton.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    importApiKeys(e.target.files[0]);
                    // Reset file input so the same file can be selected again
                    e.target.value = '';
                }
            });
            transcriptInput.addEventListener('input', updateUI);
            processAllButton.addEventListener('click', processAllPrompts);
        }

        function handleApiKeyChange() {
            const apiKey = apiKeyInput.value.trim();
            state.apiKey = apiKey;
            
            if (apiKey) {
                showApiStatus('✅ API Key ready to use', 'success');
                // Clear selector if manually entering a key
                apiKeySelector.value = '';
            } else {
                apiStatus.style.display = 'none';
            }
            
            updateUI();
        }

        function handleApiKeySelection() {
            const selectedKey = apiKeySelector.value;
            if (selectedKey) {
                state.apiKey = selectedKey;
                apiKeyInput.value = selectedKey;
                showApiStatus('✅ API Key selected from saved keys', 'success');
            }
            updateUI();
        }

        function updateUI() {
            const hasApiKey = state.apiKey.length > 0;
            const hasAvailableKeys = state.availableKeys.length > 0;
            const hasTranscript = transcriptInput.value.trim().length > 0;
            const hasLabel = apiKeyLabel.value.trim().length > 0;
            const hasNewKey = apiKeyInput.value.trim().length > 0;
            const hasSelectedKey = apiKeySelector.value.length > 0;
            
            // Can process if we have transcript and either a manual API key or saved keys for rotation
            const canProcess = hasTranscript && !state.processing && 
                              (hasApiKey || (state.autoRotate && hasAvailableKeys));
            
            const canSave = hasNewKey && hasLabel;
            const canDelete = hasSelectedKey;
            const canExport = hasAvailableKeys;
            
            // Update processing buttons
            processAllButton.disabled = !canProcess;
            
            // Update API key management buttons
            saveApiKeyButton.disabled = !canSave;
            deleteApiKeyButton.disabled = !canDelete;
            exportKeysButton.disabled = !canExport;
            
            // Update individual prompt buttons
            const individualButtons = document.querySelectorAll('.individual-process-button');
            individualButtons.forEach(button => {
                button.disabled = !canProcess;
            });
        }

        function setupIndividualPrompts() {
            individualPrompts.innerHTML = '';
            
            // Get enabled prompts in order
            const enabledPrompts = getEnabledPrompts();
            const orderedPrompts = Object.entries(enabledPrompts)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999));
            
            if (orderedPrompts.length === 0) {
                const noPrompts = document.createElement('div');
                noPrompts.className = 'prompt-item';
                noPrompts.innerHTML = `
                    <div style="text-align: center; color: #999; font-style: italic; width: 100%;">
                        No prompts enabled
                    </div>
                `;
                individualPrompts.appendChild(noPrompts);
                return;
            }
            
            orderedPrompts.forEach(([key, data]) => {
                const promptItem = document.createElement('div');
                promptItem.className = 'prompt-item';
                
                const promptName = document.createElement('div');
                promptName.className = 'prompt-name';
                promptName.textContent = data.name;
                
                const processButton = document.createElement('button');
                processButton.className = 'individual-process-button';
                processButton.textContent = 'Process';
                processButton.addEventListener('click', () => processIndividualPrompt(key, processButton));
                
                promptItem.appendChild(promptName);
                promptItem.appendChild(processButton);
                individualPrompts.appendChild(promptItem);
            });
        }

        async function callGeminiAPI(prompt, promptName = '') {
            // Get the appropriate API key (either current or rotated)
            const apiKeyToUse = getNextApiKey();
            
            if (!apiKeyToUse) {
                throw new Error('API key is required');
            }

            // Build the API URL with the selected model
            const apiUrl = `${GEMINI_API_BASE_URL}${state.selectedModel}:generateContent?key=${apiKeyToUse}`;

            // Update status to show which API key and model are being used
            let statusMessage = `Processing ${promptName}`;
            if (state.autoRotate && promptName) {
                const currentKeyInfo = state.availableKeys.find(k => k.key === apiKeyToUse);
                if (currentKeyInfo) {
                    statusMessage += ` using ${currentKeyInfo.label} (${MODELS[state.selectedModel].name})...`;
                }
            } else if (promptName) {
                statusMessage += ` using ${MODELS[state.selectedModel].name}...`;
            }
            
            if (promptName) {
                statusText.textContent = statusMessage;
            }

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }]
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                const currentKeyInfo = state.availableKeys.find(k => k.key === apiKeyToUse);
                const keyLabel = currentKeyInfo ? currentKeyInfo.label : 'Unknown';
                throw new Error(`${errorData.error?.message || 'API call failed'} (${MODELS[state.selectedModel].name}, key: ${keyLabel})`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function processAllPrompts() {
            const transcript = transcriptInput.value.trim();
            if (!transcript || (!state.apiKey && !(state.autoRotate && state.availableKeys.length > 0))) return;

            const isSameTranscript = state.lastTranscript === transcript;
            if (!isSameTranscript) {
                state.responses = {};
                renderResults();
            }
            state.lastTranscript = transcript;

            // Get only enabled prompts in order
            const enabledPrompts = getEnabledPrompts();
            const orderedPrompts = Object.entries(enabledPrompts)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999));

            if (orderedPrompts.length === 0) {
                showApiStatus('❌ No prompts enabled for processing', 'error');
                return;
            }

            const totalPrompts = orderedPrompts.length;
            let completedCount = orderedPrompts.filter(([key]) => state.responses[key]).length;

            if (completedCount === totalPrompts) {
                progressSection.style.display = 'block';
                progressFill.style.width = '100%';
                statusText.textContent = '✅ All enabled prompts already processed.';
                renderResults();
                return;
            }

            state.processing = true;
            updateUI();

            progressSection.style.display = 'block';
            progressFill.style.width = `${(completedCount / totalPrompts) * 100}%`;

            try {
                for (let i = 0; i < orderedPrompts.length; i++) {
                    const [key, data] = orderedPrompts[i];

                    if (state.responses[key]) {
                        continue;
                    }

                    if (!state.autoRotate) {
                        statusText.textContent = `Processing: ${data.name}...`;
                    }

                    const fullPrompt = `${data.prompt}\n\n---\n\n${transcript}`;
                    const response = await callGeminiAPI(fullPrompt, data.name);
                    state.responses[key] = response;
                    completedCount++;

                    renderResults();
                    progressFill.style.width = `${(completedCount / totalPrompts) * 100}%`;

                    // Small delay between requests
                    if (completedCount < totalPrompts) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                statusText.textContent = '✅ All enabled prompts processed successfully!';

            } catch (error) {
                statusText.textContent = `❌ Error: ${error.message}`;
                console.error('Processing error:', error);
            } finally {
                state.processing = false;
                updateUI();
            }
        }

        async function processIndividualPrompt(key, buttonElement) {
            const transcript = transcriptInput.value.trim();
            if (!transcript || (!state.apiKey && !(state.autoRotate && state.availableKeys.length > 0))) return;

            const data = PROMPTS[key];
            const button = buttonElement;
            const originalText = button.textContent;
            
            button.textContent = 'Processing...';
            button.disabled = true;
            
            try {
                const fullPrompt = `${data.prompt}\n\n---\n\n${transcript}`;
                const response = await callGeminiAPI(fullPrompt, data.name);
                state.responses[key] = response;
                renderResults();
            } catch (error) {
                alert(`Error processing ${data.name}: ${error.message}`);
                console.error('Processing error:', error);
            } finally {
                button.textContent = originalText;
                updateUI();
            }
        }

        function renderResults() {
            if (Object.keys(state.responses).length === 0) {
                resultsContainer.innerHTML = `
                    <div class="no-results">
                        No results yet. Process your transcript to see the analysis.
                    </div>
                `;
                return;
            }

            // Create container for tabs and content
            resultsContainer.innerHTML = `
                <div class="tabs" id="tabsContainer"></div>
                <div id="tabContentsContainer"></div>
                <div class="download-section">
                    <button class="download-button" id="downloadButton">
                        💾 Download Consolidated Report
                    </button>
                </div>
            `;

            // Get containers
            const tabsContainer = document.getElementById('tabsContainer');
            const tabContentsContainer = document.getElementById('tabContentsContainer');
            const downloadButton = document.getElementById('downloadButton');

            // Add download button event listener
            downloadButton.addEventListener('click', downloadConsolidatedReport);

            // Create tabs with proper event listeners - only for prompts that have responses
            let firstTabButton = null;
            const enabledPrompts = getEnabledPrompts();
            const orderedPrompts = Object.entries(enabledPrompts)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999));
                
            orderedPrompts.forEach(([key, data]) => {
                if (state.responses[key]) {
                    // Create tab button
                    const tabButton = document.createElement('button');
                    tabButton.className = 'tab';
                    tabButton.textContent = data.name;
                    tabButton.addEventListener('click', () => showTab(key, tabButton));
                    tabsContainer.appendChild(tabButton);
                    
                    if (!firstTabButton) firstTabButton = tabButton;

                    // Create tab content
                    const response = state.responses[key];
                    const tabContent = document.createElement('div');
                    tabContent.id = `tab-${key}`;
                    tabContent.className = 'tab-content';
                    
                    const responseContainer = document.createElement('div');
                    responseContainer.className = 'response-container';
                    
                    const responseText = document.createElement('div');
                    responseText.className = 'response-text';
                    responseText.textContent = response;
                    
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button';
                    copyButton.textContent = `📋 Copy ${data.name}`;
                    copyButton.addEventListener('click', () => copyToClipboard(key, copyButton));
                    
                    responseContainer.appendChild(responseText);
                    tabContent.appendChild(responseContainer);
                    tabContent.appendChild(copyButton);
                    tabContentsContainer.appendChild(tabContent);
                }
            });

            // Show first tab with content
            const firstKeyWithContent = Object.keys(state.responses)[0];
            if (firstKeyWithContent && firstTabButton) {
                showTab(firstKeyWithContent, firstTabButton);
            }
        }

        function showTab(key, tabElement) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            const tabContent = document.getElementById(`tab-${key}`);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Add active class to selected tab
            if (tabElement) {
                tabElement.classList.add('active');
            }
        }

        function formatResponse(text) {
            // Simple HTML escaping and preserve line breaks
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function copyToClipboard(key, buttonElement) {
            const response = state.responses[key];
            if (!response) return;
            
            navigator.clipboard.writeText(response).then(() => {
                // Show temporary feedback
                if (buttonElement) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = '✅ Copied!';
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback: create a temporary textarea
                const textarea = document.createElement('textarea');
                textarea.value = response;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                // Show feedback even on fallback
                if (buttonElement) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = '✅ Copied!';
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                    }, 2000);
                }
            });
        }

        function downloadConsolidatedReport() {
            const date = new Date().toISOString().split('T')[0];
            let output = `# AI Analysis Results - ${date}\n\n`;
            
            // Map prompt keys to custom section titles
            const sectionTitles = {
                "highlights_reflection": "# High/Low Light and Reflection",
                "todo_list": "# TodoList",
                "daily_chart": "# DailyChart",
                "suggestion": "# Suggestion", 
                "summary": "# Summary",
                "daily_logs": "# Daily Logs",
                "new_learning": "# New Learning"
            };
            
            // Get responses in order based on enabled prompts
            const enabledPrompts = getEnabledPrompts();
            const orderedPrompts = Object.entries(enabledPrompts)
                .sort(([,a], [,b]) => (a.order || 999) - (b.order || 999));
            
            orderedPrompts.forEach(([key, data]) => {
                if (key in state.responses) {
                    const title = sectionTitles[key] || `# ${data.name}`;
                    output += `${title}\n\n`;
                    output += state.responses[key];
                    output += '\n\n---\n\n';
                }
            });
            
            const blob = new Blob([output], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `daily_analysis_${date.replace(/-/g, '')}_${new Date().getHours()}${new Date().getMinutes()}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
